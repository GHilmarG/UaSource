<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>QuiverColorGHG</title>
<meta name="generator" content="MATLAB 24.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-12-30">
<meta name="DC.source" content="QuiverColorGHG.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#2">Plot velocity using colours/colors</a>
</li>
</ul>
</div>
<pre class="codeinput">
<span class="keyword">function</span> [cbar,QuiverHandel,Par]=QuiverColorGHG(x,y,u,v,Par,varargin)
</pre>
<h2 id="2">Plot velocity using colours/colors</h2>
<p>Just a wrapper around quiver to generate coloured arrow field with a colorbar.</p>
<pre class="language-matlab">[cbar,QuiverHandel,Par]=QuiverColorGHG(x,y,u,v,Par,varargin)
</pre>
<p>x , y , u , v : vectors of same length. But if using regular velocity grid, x and y can be grid vectors. (In MATLAB speak grid vectors xg and yg are a set of vectors that serve as a compact representation of a grid in ndgrid format. For example, [X,Y] = ndgrid(xg,yg) )</p>
<pre class="language-matlab">Par.RelativeVelArrowSize                   : affects the <span class="string">size</span> <span class="string">of</span> <span class="string">the</span> <span class="string">velocity</span> <span class="string">arrows.</span>
                                             by <span class="string">default</span> <span class="string">Par.RelativeVelArrowSize=1.</span>
                                             Increase <span class="string">value</span> <span class="string">for</span> <span class="string">larger</span> <span class="string">arrows.</span>
Par.QuiverColorSpeedLimits=[min max]        : Speed range <span class="string">being</span> <span class="string">colored</span>, leave <span class="string">empty</span> <span class="string">for</span> <span class="string">auto.</span>
                                             Note <span class="string">however</span> <span class="string">that</span> <span class="string">when</span> <span class="string">plotting</span>
                                             using <span class="string">log10</span> <span class="string">scaling</span> <span class="string">the</span> <span class="string">min</span> <span class="string">speed</span>
                                             colored <span class="string">will</span> <span class="string">be</span> <span class="string">some</span> <span class="string">fraction</span> <span class="string">of</span> <span class="string">the</span>
                                             max <span class="string">speed</span> <span class="string">based</span> <span class="string">on</span> <span class="string">the</span> <span class="string">value</span> <span class="string">of</span>
                                           Par.QuiverColorPowRange
                                         : scaling factor <span class="string">for</span> <span class="string">arrow</span> <span class="string">size</span>, default <span class="string">value</span> <span class="string">is</span> <span class="string">1</span>
Par.VelArrowColorSteps                     : number of <span class="string">coloring</span> <span class="string">steps</span>, default <span class="string">is</span> <span class="string">20</span>
Par.VelColorBarTitle                       : default value <span class="string">is</span> <span class="string">'(m a^{-1})'</span> ;
Par.PlotXYscale                            : default value <span class="string">is</span> <span class="string">1</span>
Par.VelColorMap                            : default value <span class="string">is</span> <span class="string">'jet'</span>
Par.MinSpeedToPlot                         : where speed <span class="string">is</span> <span class="string">less</span>, speed <span class="string">is</span> <span class="string">not</span> <span class="string">plotted</span>, default <span class="string">value</span> <span class="string">is</span> <span class="string">zero</span>
Par.VelPlotIntervalSpacing=<span class="string">'lin'</span>|<span class="string">'log10'</span>   : lin or <span class="string">log10</span> <span class="string">vel</span> <span class="string">scale</span>
Par.MaxPlottedSpeed                        : When plotting, speed <span class="string">above</span> <span class="string">this</span> <span class="string">value</span> <span class="string">is</span> <span class="string">set</span> <span class="string">equal</span> <span class="string">to</span> <span class="string">this</span> <span class="string">value</span>, i.e. this is <span class="string">the</span> <span class="string">maximum</span> <span class="string">plotted</span> <span class="string">speed</span>
                                               Default <span class="string">is</span> <span class="string">max(speed(:))</span>
Par.MinPlottedSpeed                        : When plotting, speed <span class="string">below</span> <span class="string">this</span> <span class="string">value</span> <span class="string">is</span> <span class="string">set</span> <span class="string">equal</span> <span class="string">to</span> <span class="string">this</span> <span class="string">value</span>, i.e. this is <span class="string">the</span> <span class="string">mainimum</span> <span class="string">plotted</span> <span class="string">speed</span>
                                               Default <span class="string">is</span> <span class="string">min(speed(:)).</span>
                                               However, <span class="keyword">if</span> using log10 <span class="string">the</span> <span class="string">minimum</span> <span class="string">plotted</span> <span class="string">speed</span> <span class="string">is</span> <span class="string">never</span> <span class="string">smaller</span> <span class="string">than</span> <span class="string">10^QshouldiverColorPowRange</span> <span class="string">times</span> <span class="string">MaxPlottedSpeed</span>
Par.SpeedTickLabels                        : numerical array <span class="string">of</span> <span class="string">values</span>
Par.QuiverColorPowRange                    : when using <span class="string">log10</span> <span class="string">velocity</span> <span class="string">bar</span>, this <span class="string">is</span> <span class="string">the</span> <span class="string">creates</span> <span class="string">possible</span> <span class="string">range</span> <span class="string">of</span> <span class="string">magnitudes</span> <span class="string">shown</span> <span class="string">in</span> <span class="string">colobar.</span>
                                           Default <span class="string">is</span>
                                           Par.QuiverColorPowRange=3, i.e.
                                           the <span class="string">smallest</span> <span class="string">colored</span> <span class="string">speed</span> <span class="string">is</span>
                                           10^3 smaller <span class="string">than</span> <span class="string">the</span> <span class="string">largest</span> <span class="string">speed</span>
Par.QuiverSameVelocityScalingsAsBefore      : set to <span class="string">true</span> <span class="string">(ie 1)</span> <span class="string">to</span> <span class="string">get</span> <span class="string">same</span> <span class="string">velocity</span> <span class="string">scaling</span> <span class="string">as</span> <span class="string">in</span> <span class="string">previous</span> <span class="string">call.</span>
</pre>
<p>varargin is passed on to quiver</p>
<p>
<b>Examples:</b>
</p>
<pre>figure
load('CrackRestartfileExample.mat','CtrlVarInRestartFile','MUA','F','BCs','GF')
QuiverColorGHG(MUA.coordinates(:,1),MUA.coordinates(:,2),F.ub,F.vb);</pre>
<p>Plot all velocities with arrows of equal length:</p>
<pre>load('CrackRestartfileExample.mat','CtrlVarInRestartFile','MUA','F','BCs','GF')
 CtrlVar=CtrlVarInRestartFile;
speed=sqrt(F.ub.*F.ub+F.vb.*F.vb);
Par.MinPlottedSpeed=max(speed);
Par.VelColorBarTitle=' ';
Par.PlotXYscale=CtrlVar.PlotXYscale
figure
QuiverColorGHG(MUA.coordinates(:,1),MUA.coordinates(:,2),F.ub,F.vb,Par);
hold on ; PlotMuaBoundary(CtrlVar,MUA,'k')</pre>
<p>Plot velocities at approx equally spaced intervals:</p>
<pre class="language-matlab">load(<span class="string">'CrackRestartfileExample.mat'</span>,<span class="string">'CtrlVarInRestartFile'</span>,<span class="string">'MUA'</span>,<span class="string">'F'</span>,<span class="string">'BCs'</span>,<span class="string">'GF'</span>)
CtrlVar=CtrlVarInRestartFile;
x=MUA.coordinates(:,1);  y=MUA.coordinates(:,2);
[X,Y]=ndgrid(linspace(min(x),max(x),20),linspace(min(y),max(y),20));
I=nearestNeighbor(MUA.TR,[X(:) Y(:)]);  <span class="comment">% finds nodes within computational grid closest to the regularly shaped X and Y grid points.</span>
FigVelocities=figure;
Par.PlotXYscale=CtrlVar.PlotXYscale ;
Par.MinPlottedSpeed=0;
QuiverColorGHG(MUA.coordinates(I,1),MUA.coordinates(I,2),F.ub(I),F.vb(I),Par);
hold <span class="string">on</span> ; PlotMuaBoundary(CtrlVar,MUA,<span class="string">'k'</span>)
</pre>
<p>Plot velocities using logarithmic scaling.</p>
<pre class="language-matlab">load(<span class="string">'CrackRestartfileExample.mat'</span>,<span class="string">'CtrlVarInRestartFile'</span>,<span class="string">'MUA'</span>,<span class="string">'F'</span>,<span class="string">'BCs'</span>,<span class="string">'GF'</span>)
CtrlVar=CtrlVarInRestartFile;
FigVelocities=figure;
CtrlVar.VelPlotIntervalSpacing=<span class="string">'log10'</span> ;
QuiverColorGHG(MUA.coordinates(:,1),MUA.coordinates(:,2),F.ub,F.vb,CtrlVar);
hold <span class="string">on</span> ; PlotMuaBoundary(CtrlVar,MUA,<span class="string">'k'</span>)
</pre>
<p>Plotting velocities on top of FE mesh:</p>
<pre class="language-matlab">load(<span class="string">'CrackRestartfileExample.mat'</span>,<span class="string">'CtrlVarInRestartFile'</span>,<span class="string">'MUA'</span>,<span class="string">'F'</span>,<span class="string">'BCs'</span>,<span class="string">'GF'</span>)
CtrlVar=CtrlVarInRestartFile;
PlotMuaMesh(CtrlVar,MUA)
hold <span class="string">on</span>
QuiverColorGHG(x,y,F.ub,F.vb,CtrlVar);
</pre>
<p>Two calls with same velocity scaling:</p>
<pre class="language-matlab">[cbar,~,Par]=QuiverColorGHG(x,y,u,v,Par)  ; <span class="comment">% first call, here Par is not strictly needed as an input</span>
Par.QuiverSameVelocityScalingsAsBefore=1;
QuiverColorGHG(x,y,u,v,Par) ; <span class="comment">% second call uses same scaling as previous one</span>
</pre>
<p>Note: When doing further contour plots on top of velocity plot, MATLAB will possibly change the limits of the colorbar and the position of the ticklables will no longer be correct. If this happens then reset range and ticks, for example:</p>
<pre class="language-matlab">[~,~,Par]=QuiverColorGHG(x,y,ub,vb);
<span class="keyword">...</span><span class="comment">some other plots that affect the colorbar labels, colors, etc...</span>
cbar=colorbar;
cbar.Ticks=Par.QuiverTicks*(cbar.Limits(2)-cbar.Limits(1))+cbar.Limits(1);
cbar.TickLabels=Par.QuiverTickLabels;
title(cbar,<span class="string">'(m/d)'</span>)   ;
</pre>
<p>Note: The variable Par is modified in the call and will, in general, be modified on return. If the same Par variable is then used again as an input to a subsequent call to QuiverColorGHG, those (modified) parameter values might affect the plot. The problem can be avoided by re-setting Par=[] in the second call, or by setting</p>
<pre>  Par.QuiverSameVelocityScalingsAsBefore=false ;
  Par.MaxPlottedSpeed=[] ;
  Par.MinPlottedSpeed=[] ;
  Par.QuiverColorSpeedLimits=[];</pre>
<p>ahead of a second call when using Par from a previous call.</p>
<pre class="codeinput">
<span class="keyword">persistent</span> SpeedPlotIntervals uvPlotScale QuiverTickLabels QuiverTicks QuiverCmap

<span class="keyword">if</span> ~Par.QuiverSameVelocityScalingsAsBefore

    SpeedPlotIntervals=[];
    uvPlotScale=[];
    QuiverTickLabels=[];
    QuiverTicks=[];
    QuiverCmap=[];

    <span class="comment">% if nargin&gt;4</span>
    <span class="comment">%</span>
    <span class="comment">%     Par.MaxPlottedSpeed=[] ;</span>
    <span class="comment">%     Par.MinPlottedSpeed=[] ;</span>
    <span class="comment">%     % Par.QuiverColorSpeedLimits=[] ;</span>
    <span class="comment">%     % Par.VelPlotIntervalSpacing=[] ;</span>
    <span class="comment">%     % Par.VelArrowColorSteps=[] ;</span>
    <span class="comment">%     % Par.VelColorMap =[] ;</span>
    <span class="comment">%     % Par.SpeedTickLabels=[] ;</span>
    <span class="comment">%</span>
    <span class="comment">% end</span>



<span class="keyword">end</span>

cbar=[];
QuiverHandel=[];

<span class="keyword">if</span> isempty(x) || isempty(y) || isempty(u)   || isempty(v)
    <span class="keyword">return</span>
<span class="keyword">end</span>


<span class="keyword">if</span> size(u,2)== 1 &amp;&amp; (numel(x) ~= numel(y))
    error(<span class="string">'Ua:QuiverColorGHG:xyDimensionsNotCompatible'</span>,<span class="string">'x and y must have the same number of elements.'</span>)
<span class="keyword">end</span>


<span class="keyword">if</span> numel(u) ~= numel(v)
    error(<span class="string">'Ua:QuiverColorGHG:uvDimensionsNotCompatible'</span>,<span class="string">'u and v must have the same number of elements.'</span>)
<span class="keyword">end</span>

<span class="comment">%</span>
<span class="comment">% The expected typical usage is to plot one-dimensional arrays of velocities</span>
<span class="comment">% But u, v, x ,and y can also be given on a grid.</span>
<span class="comment">% If u and v is given on a grid, create vectors</span>



<span class="keyword">if</span> size(u,1)&gt; 1 &amp;&amp; size(u,2)&gt;1 &amp;&amp; ((size(x,2)==1 &amp;&amp; size(y,2)==1)  || (size(x,1)==1 &amp;&amp; size(y,1)==1 ))

    <span class="comment">% u and v are matrices , x and y are vectors</span>
    x=x(:) ; y=y(:) ;

    <span class="keyword">if</span> size(u)==size(v)

        <span class="keyword">if</span> (size(x,1)==size(u,1)) &amp;&amp; (size(y,1)==size(u,2))

            [X,Y]=ndgrid(x,y) ;
            x=X(:) ; y=Y(:) ; u=u(:) ; v=v(:);
            clear <span class="string">X</span> <span class="string">Y</span>

        <span class="keyword">elseif</span> (size(x,1)==size(u,2)) &amp;&amp; (size(y,1)==size(u,1))

            warning(<span class="string">'QuiverColorGHG:wrongdimensions'</span>,<span class="string">'x and y are not grid vectors'</span>)

            [X,Y]=meshgrid(x,y) ;
            x=X(:) ; y=Y(:) ; u=u(:) ; v=v(:);
            clear <span class="string">X</span> <span class="string">Y</span>

        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

x=x(:) ; y=y(:) ; u=u(:) ; v=v(:);

speed=sqrt(u.*u+v.*v); <span class="comment">% speed is never scaled, so I can use speed to color velocity field based on values</span>

<span class="keyword">if</span> isinf(max(speed))

    fprintf(<span class="string">' Max of speed is infinite\n'</span>)

    I=isinf(speed);
    u(I)=NaN ; v(I)=NaN ; speed(I)=NaN;
    fprintf(<span class="string">' Seeting all such velocity values to NaN \n'</span>)

<span class="keyword">end</span>


<span class="comment">% now check Par fields, use all user-defined values where available, use default values otherwise</span>
<span class="comment">% and put in some reasonable for the remaining fields</span>

<span class="keyword">if</span> nargin&gt;4 &amp;&amp; ~isempty(Par)

    <span class="keyword">if</span> ~isfield(Par,<span class="string">'QuiverColorPowRange'</span>)
        Par.QuiverColorPowRange=3;
    <span class="keyword">end</span>

    <span class="keyword">if</span> ~isfield(Par,<span class="string">'MaxPlottedSpeed'</span>)  || isempty(Par.MaxPlottedSpeed)

        <span class="keyword">if</span> isfield(Par,<span class="string">'QuiverColorSpeedLimits'</span>)  &amp;&amp; ~isempty(Par.QuiverColorSpeedLimits)
            Par.MaxPlottedSpeed=Par.QuiverColorSpeedLimits(2);
        <span class="keyword">else</span>


            <span class="keyword">if</span> all(speed==0)
                ticks=logticks(speed,Par.QuiverColorPowRange);
                Par.MaxPlottedSpeed=max(ticks);

            <span class="keyword">else</span>
                <span class="comment">%Par.MaxPlottedSpeed=max(speed(:))*1.001;</span>
                Par.MaxPlottedSpeed=max(speed(:));
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>


    <span class="keyword">if</span> ~isfield(Par,<span class="string">'MinPlottedSpeed'</span>)  || isempty(Par.MinPlottedSpeed)
        Par.MinPlottedSpeed=0;
    <span class="keyword">end</span>

    <span class="keyword">if</span> ~isfield(Par,<span class="string">'VelPlotIntervalSpacing'</span>) || isempty(Par.VelPlotIntervalSpacing)
        Par.VelPlotIntervalSpacing=<span class="string">'lin'</span>;
    <span class="keyword">end</span>


    <span class="keyword">if</span> ~isfield(Par,<span class="string">'QuiverColorSpeedLimits'</span>)  || isempty(Par.QuiverColorSpeedLimits)

        <span class="keyword">switch</span> Par.VelPlotIntervalSpacing
            <span class="keyword">case</span> <span class="string">'log10'</span>

                ticks=logticks(speed,Par.QuiverColorPowRange,12);
                Par.QuiverColorSpeedLimits(1)=min(ticks);
                Par.QuiverColorSpeedLimits(2)=max(ticks);
            <span class="keyword">case</span> <span class="string">'lin'</span>

                Par.QuiverColorSpeedLimits(1)=min(speed);
                Par.QuiverColorSpeedLimits(2)=max(speed);
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">if</span> ~isfield(Par,<span class="string">'uvPlotScale'</span>)
        Par.uvPlotScale=[];
    <span class="keyword">end</span>


    <span class="keyword">if</span> ~isfield(Par,<span class="string">'RelativeVelArrowSize'</span>) || isempty(Par.RelativeVelArrowSize)
        Par.RelativeVelArrowSize=1; <span class="comment">% larger value makes vel arrows larger</span>
    <span class="keyword">end</span>

    <span class="keyword">if</span> ~isfield(Par,<span class="string">'VelColorMap'</span>)
        Par.VelColorMap=<span class="string">'jet'</span>;
    <span class="keyword">end</span>

    <span class="keyword">if</span> ~isfield(Par,<span class="string">'PlotXYscale'</span>)
        Par.PlotXYscale=1;
    <span class="keyword">end</span>

    <span class="keyword">if</span> ~isfield(Par,<span class="string">'VelArrowColorSteps'</span>)
        Par.VelArrowColorSteps=50;
    <span class="keyword">end</span>

    <span class="keyword">if</span> ~isfield(Par,<span class="string">'VelColorBarTitle'</span>)
        Par.VelColorBarTitle=<span class="string">"($\mathrm{m \, yr^{-1}}$)"</span> ;
    <span class="keyword">end</span>



    <span class="keyword">if</span> ~isfield(Par,<span class="string">'MinSpeedToPlot'</span>)
        Par.MinSpeedToPlot=0;
    <span class="keyword">end</span>

    <span class="keyword">if</span> ~isfield(Par,<span class="string">'SpeedTickLabels'</span>)
        Par.SpeedTickLabels=[];
    <span class="keyword">end</span>

    <span class="keyword">if</span> ~isfield(Par,<span class="string">'QuiverCmap'</span>)
        Par.QuiverCmap=[];
    <span class="keyword">end</span>

    <span class="keyword">if</span> ~isfield(Par,<span class="string">'QuiverSameVelocityScalingsAsBefore'</span>)
        Par.QuiverSameVelocityScalingsAsBefore=false ;
    <span class="keyword">end</span>

    <span class="keyword">if</span> Par.QuiverSameVelocityScalingsAsBefore

        <span class="keyword">if</span> ~isempty(uvPlotScale)

            Par.uvPlotScale=uvPlotScale ;
            Par.SpeedPlotIntervals=SpeedPlotIntervals ;
            Par.QuiverTickLabels=QuiverTickLabels;
            Par.QuiverTicks=QuiverTicks ;
            Par.QuiverCmap=QuiverCmap;

        <span class="keyword">else</span>
            Par.QuiverSameVelocityScalingsAsBefore=false ;
            fprintf(<span class="string">'In QuiverColorGHG same scaling as in a previous call is requested, but the velocity scaling factor is not defined.\n'</span>)
            fprintf(<span class="string">'Therefore, setting QuiverSameVelocityScalingsAsBefore=false \n'</span>)

        <span class="keyword">end</span>
    <span class="keyword">end</span>

<span class="keyword">else</span>

    Par.RelativeVelArrowSize=1; <span class="comment">% larger value makes vel arrows larger</span>
    Par.VelArrowColorSteps=50;
    Par.uvPlotScale=[];
    Par.VelColorBarTitle=<span class="string">"($\mathrm{m \, yr^{-1}}$)"</span> ;
    Par.PlotXYscale=1;
    Par.VelColorMap=<span class="string">'jet'</span>;
    Par.MaxPlottedSpeed=max(speed(:));
    Par.MinPlottedSpeed=min(speed(:));
    Par.VelPlotIntervalSpacing=<span class="string">'lin'</span>;
    Par.QuiverColorSpeedLimits(1)=min(speed(:));
    Par.QuiverColorSpeedLimits(2)=max(speed(:));
    Par.MinSpeedToPlot=0;
    Par.SpeedTickLabels=[];
    Par.QuiverColorPowRange=3;
    Par.QuiverCmap=[];
    Par.QuiverSameVelocityScalingsAsBefore=0;

<span class="keyword">end</span>
</pre>
<p>now all input variables should be OK</p>
<pre class="codeinput">N=Par.VelArrowColorSteps;

<span class="keyword">if</span> Par.QuiverSameVelocityScalingsAsBefore

    colormap(QuiverCmap)

    <span class="keyword">if</span> isempty(Par.uvPlotScale) || ~isfield(Par,<span class="string">'uvPlotScale'</span>)
        fprintf(<span class="string">'In QuiverColorGHG same scaling as in a previous call is requested, but the velocity scaling factor is not defined.\n'</span>)
        fprintf(<span class="string">'Use parameters from previous call in this call!\n'</span>)
        error(<span class="string">'Ua:QuiverColorGHG'</span>,<span class="string">'The field uvPlotScale is not defiend'</span>)
    <span class="keyword">end</span>
<span class="keyword">else</span>


    <span class="keyword">if</span> strcmp(Par.VelPlotIntervalSpacing,<span class="string">'log10'</span>)==1
        <span class="comment">% create a `logarithmic' colormap</span>

        <span class="keyword">if</span> ~isnumeric(Par.VelColorMap)
            NN=10*N ;
            cmap=colormap(sprintf(<span class="string">'%s(%i)'</span>,Par.VelColorMap,NN));
        <span class="keyword">else</span>
            cmap=Par.VelColorMap ;
            NN=size(cmap,1);
        <span class="keyword">end</span>
        index=fix((NN-1)*(exp((0:N-1)/(N-1))-1)/(exp(1)-1)+1);
        cmap=colormap(cmap(index,:));
    <span class="keyword">else</span>

        <span class="keyword">if</span> ~isnumeric(Par.VelColorMap)
            cmap=colormap(sprintf(<span class="string">'%s(%i)'</span>,Par.VelColorMap,N));
        <span class="keyword">else</span>
            cmap=Par.VelColorMap ;
            N=size(cmap,1);
        <span class="keyword">end</span>
    <span class="keyword">end</span>


    <span class="keyword">switch</span> Par.VelPlotIntervalSpacing

        <span class="keyword">case</span> <span class="string">'log10'</span>

            ticks=logticks(speed,Par.QuiverColorPowRange,12,Par.QuiverColorSpeedLimits);

            MinTick=min(ticks);

            <span class="keyword">if</span> Par.QuiverColorSpeedLimits(1)&lt;MinTick

                <span class="comment">%Par.MinPlottedSpeed=MinTick;</span>
                Par.QuiverColorSpeedLimits(1)=MinTick;
            <span class="keyword">end</span>


            Par.SpeedPlotIntervals=logspace(log10(Par.QuiverColorSpeedLimits(1)),log10(Par.QuiverColorSpeedLimits(2)),N+1);

        <span class="keyword">case</span> <span class="string">'lin'</span>

            <span class="comment">%Par.SpeedPlotIntervals=linspace(Par.MinPlottedSpeed,Par.MaxPlottedSpeed,N+1);</span>
            Par.SpeedPlotIntervals=linspace(Par.QuiverColorSpeedLimits(1),Par.QuiverColorSpeedLimits(2),N+1);

        <span class="keyword">otherwise</span>
            fprintf(<span class="string">' which case {log10,lin}?'</span> )
            error(<span class="string">'QuiverColorGHG:VelPlotIntervalSpacing'</span>,<span class="string">'case not reckognized'</span>)
    <span class="keyword">end</span>




    Par.QuiverCmap=cmap;


    <span class="comment">% scaling of velocity to get reasonably sized arrows</span>


    Np=(sqrt(numel(x))/10);

    <span class="keyword">if</span> Np&lt;30 ; Np=30 ; <span class="keyword">end</span>

    ps=min([max(x)-min(x) max(y)-min(y)])/Par.PlotXYscale*Par.RelativeVelArrowSize/Np;
    Par.uvPlotScale = Par.QuiverColorSpeedLimits(2)/ps  ;


<span class="keyword">end</span>

uplot=u ; vplot=v;

<span class="comment">% set velocities within plotting range</span>
Ind=speed &gt; Par.MaxPlottedSpeed;
uplot(Ind)=uplot(Ind)*Par.MaxPlottedSpeed./speed(Ind);
vplot(Ind)=vplot(Ind)*Par.MaxPlottedSpeed./speed(Ind);

Ind=speed &lt; Par.MinPlottedSpeed;
uplot(Ind)=uplot(Ind)*Par.MinPlottedSpeed./speed(Ind);
vplot(Ind)=vplot(Ind)*Par.MinPlottedSpeed./speed(Ind);



<span class="comment">%fprintf('QuiverColorGHG: uvPlotScale=%f \n',Par.uvPlotScale)</span>

uplot=uplot/Par.uvPlotScale; vplot=vplot/Par.uvPlotScale;

<span class="comment">%SpeedPlot=sqrt(uplot.*uplot+vplot.*vplot);</span>
<span class="comment">%sc=log(1+SpeedPlot)./x  ; I=isnan(sc) ; sc(I)=1;</span>

<span class="comment">% end</span>

<span class="keyword">for</span> J=1:numel(Par.SpeedPlotIntervals)-1

    <span class="keyword">switch</span> J
        <span class="keyword">case</span> 1
            I=speed &lt;= Par.SpeedPlotIntervals(J+1) &amp; speed&gt;Par.MinSpeedToPlot;
        <span class="keyword">case</span> N
            I=speed&gt;Par.SpeedPlotIntervals(J) &amp; speed&gt;Par.MinSpeedToPlot;
        <span class="keyword">otherwise</span>
            I=speed&gt;Par.SpeedPlotIntervals(J) &amp; speed &lt;= Par.SpeedPlotIntervals(J+1) &amp; speed&gt;Par.MinSpeedToPlot;
    <span class="keyword">end</span>

    <span class="keyword">if</span> numel(x(I))&gt;0  <span class="comment">% This should not really be needed, but</span>
        <span class="comment">% results in errors in Matlab2016a</span>
        QuiverHandel=quiver(x(I)/Par.PlotXYscale,y(I)/Par.PlotXYscale,uplot(I),vplot(I),0,<span class="keyword">...</span>
            <span class="string">'color'</span>,Par.QuiverCmap(J,:),varargin{:}) ; hold <span class="string">on</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>


nPowRange=Par.QuiverColorPowRange;

<span class="keyword">if</span> ~Par.QuiverSameVelocityScalingsAsBefore

    <span class="keyword">if</span> verLessThan(<span class="string">'matlab'</span>,<span class="string">'8.4'</span>)

        <span class="comment">%pre 2014b version</span>
        cbar=colorbar; title(cbar,Par.VelColorBarTitle,<span class="string">"interpreter"</span>,<span class="string">"latex"</span>)   ;

        <span class="keyword">if</span> strcmp(Par.VelPlotIntervalSpacing,<span class="string">'log10'</span>)==1

            ms=fix(log10(Par.MaxPlottedSpeed));
            ticklabel=logspace(0,ms,ms+1);
            tickpos=1+N*log10(ticklabel)/log10(Par.SpeedPlotIntervals(N+1));
            set(cbar,<span class="string">'Ytick'</span>,tickpos,<span class="string">'YTicklabel'</span>,ticklabel);
        <span class="keyword">else</span>
            clim([0 max(Par.SpeedPlotIntervals)]);
        <span class="keyword">end</span>


    <span class="keyword">else</span>

        <span class="keyword">if</span> strcmp(Par.VelPlotIntervalSpacing,<span class="string">'log10'</span>)==1


            <span class="keyword">if</span> ~isempty(Par.SpeedTickLabels)
                ticklabel=log10(Par.SpeedTickLabels);
            <span class="keyword">else</span>
                <span class="comment">% this is for more pleasing interval between labels (but needs to be improved)</span>
                <span class="comment">%D=(max(sp)-min(sp))/10 ; D=10.^round(log10(D)) ; ticklabel=unique(D*round(sp/D));</span>
                ticklabel=logticks(speed,nPowRange,12,Par.SpeedPlotIntervals);
                <span class="comment">%ticks=logticks(speed,12,Par.QuiverColorPowRange);</span>
            <span class="keyword">end</span>


            tickpos=(log10(ticklabel)-min(log10(Par.SpeedPlotIntervals)))/(max(log10(Par.SpeedPlotIntervals))-min(log10(Par.SpeedPlotIntervals)));


        <span class="keyword">else</span>

            <span class="keyword">if</span> ~isempty(Par.SpeedTickLabels)

                ticklabel=Par.SpeedTickLabels;
            <span class="keyword">else</span>

                <span class="comment">% this is for (hopefully) a more pleasing interval between labels</span>
                D=(max(Par.SpeedPlotIntervals)-min(Par.SpeedPlotIntervals));
                <span class="keyword">if</span> D==0  <span class="comment">% special case if all values same or all values zero</span>
                    D=mean(Par.SpeedPlotIntervals);
                    <span class="keyword">if</span> D==0
                        ticklabel=[-1 0 1];
                        tickpos=(ticklabel+1)/2;
                    <span class="keyword">else</span>
                        ticklabel=[D/2 D 1.5*D];
                        tickpos=(ticklabel-D/2)/D;
                    <span class="keyword">end</span>
                <span class="keyword">else</span>

                    D=double(10.^floor(log10(D)))/4 ;

                    first=D*floor(Par.SpeedPlotIntervals(1)/D);
                    last=D*ceil(Par.SpeedPlotIntervals(end)/D);

                    ticklabel=first:D:last;
                    tickpos=(ticklabel-min(Par.SpeedPlotIntervals))/(max(Par.SpeedPlotIntervals)-min(Par.SpeedPlotIntervals));
                    <span class="comment">%tickpos=(ticklabel-first)/(last-first);</span>

                    <span class="keyword">if</span> numel(ticklabel)&gt;10

                        ticklabel=ticklabel(1:2:end) ;
                        tickpos=tickpos(1:2:end) ;

                    <span class="keyword">end</span>

                <span class="keyword">end</span>
                <span class="comment">%ticklabel=unique(D*round(sp/D));</span>

            <span class="keyword">end</span>


        <span class="keyword">end</span>


        <span class="keyword">if</span> any(isnan(tickpos))
            warning(<span class="string">'QuiverColorGHG:NANinTickPos'</span>,<span class="string">'calculated positions of ticks on the colorbar contain NaNs'</span>)
        <span class="keyword">end</span>

        [tickpos,ia]=unique(tickpos);

        ticklabel=ticklabel(ia);
        colormap(Par.QuiverCmap)
        cbar=colorbar ;

        <span class="comment">%cbar.TickLabels=ticklabel ;</span>


        <span class="keyword">if</span> ~any(isnan(tickpos))
            Ticks=tickpos*(cbar.Limits(2)-cbar.Limits(1))+cbar.Limits(1);
            <span class="comment">%cbar.Ticks=Ticks; % tickpos*(cbar.Limits(2)-cbar.Limits(1))+cbar.Limits(1);</span>
        <span class="keyword">end</span>

        axis <span class="string">equal</span>



        Par.QuiverTickLabels=ticklabel;
        Par.QuiverTicks=Ticks;

    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">if</span> isempty(cbar)
    cbar=colorbar;
<span class="keyword">end</span>
title(cbar,Par.VelColorBarTitle,<span class="string">"interpreter"</span>,<span class="string">"latex"</span>)   ;
cbar.TickLabels=Par.QuiverTickLabels;
cbar.Ticks=Par.QuiverTicks;

<span class="comment">% Par.QuiverColorSpeedLimits=[min(Par.SpeedPlotIntervals) max(Par.SpeedPlotIntervals)];</span>
<span class="comment">% Par.QuiverColorSpeedLimits=[];  % don't reuse these setting in next call</span>


axis <span class="string">equal</span>
<span class="comment">% axis([min(x)/Par.PlotXYscale max(x)/Par.PlotXYscale min(y)/Par.PlotXYscale max(y)/Par.PlotXYscale])</span>

uvPlotScale=Par.uvPlotScale ;
SpeedPlotIntervals=Par.SpeedPlotIntervals ;
QuiverTickLabels=Par.QuiverTickLabels;
QuiverTicks=Par.QuiverTicks ;
QuiverCmap=Par.QuiverCmap;
</pre>
<pre class="codeinput">
<span class="keyword">end</span>
</pre>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2024b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
function [cbar,QuiverHandel,Par]=QuiverColorGHG(x,y,u,v,Par,varargin)

%% Plot velocity using colours/colors
%
% Just a wrapper around quiver to generate coloured arrow field with a colorbar.
%
%   [cbar,QuiverHandel,Par]=QuiverColorGHG(x,y,u,v,Par,varargin)
%
% x , y , u , v : vectors of same length. But if using regular velocity grid, x and y can
% be grid vectors. (In MATLAB speak grid vectors xg and yg are a set of vectors that serve
% as a compact representation of a grid in ndgrid format. For example, [X,Y] =
% ndgrid(xg,yg) )
%
%
%   Par.RelativeVelArrowSize                   : affects the size of the velocity arrows.
%                                                by default Par.RelativeVelArrowSize=1.
%                                                Increase value for larger arrows.
%   Par.QuiverColorSpeedLimits=[min max]        : Speed range being colored, leave empty for auto.
%                                                Note however that when plotting
%                                                using log10 scaling the min speed
%                                                colored will be some fraction of the
%                                                max speed based on the value of
%                                              Par.QuiverColorPowRange
%                                            : scaling factor for arrow size, default value is 1
% Par.VelArrowColorSteps                     : number of coloring steps, default is 20
% Par.VelColorBarTitle                       : default value is '(m a^{-1})' ;
% Par.PlotXYscale                            : default value is 1
% Par.VelColorMap                            : default value is 'jet'
% Par.MinSpeedToPlot                         : where speed is less, speed is not plotted, default value is zero
% Par.VelPlotIntervalSpacing='lin'|'log10'   : lin or log10 vel scale
% Par.MaxPlottedSpeed                        : When plotting, speed above this value is set equal to this value, i.e. this is the maximum plotted speed
%                                                  Default is max(speed(:))
% Par.MinPlottedSpeed                        : When plotting, speed below this value is set equal to this value, i.e. this is the mainimum plotted speed
%                                                  Default is min(speed(:)).
%                                                  However, if using log10 the minimum plotted speed is never smaller than 10^QshouldiverColorPowRange times MaxPlottedSpeed
% Par.SpeedTickLabels                        : numerical array of values
% Par.QuiverColorPowRange                    : when using log10 velocity bar, this is the creates possible range of magnitudes shown in colobar.
%                                              Default is
%                                              Par.QuiverColorPowRange=3, i.e.
%                                              the smallest colored speed is
%                                              10^3 smaller than the largest speed
% Par.QuiverSameVelocityScalingsAsBefore      : set to true (ie 1) to get same velocity scaling as in previous call.
%
%
% varargin is passed on to quiver
%
% *Examples:*
%
%  figure
%  load('CrackRestartfileExample.mat','CtrlVarInRestartFile','MUA','F','BCs','GF')
%  QuiverColorGHG(MUA.coordinates(:,1),MUA.coordinates(:,2),F.ub,F.vb);
%
% Plot all velocities with arrows of equal length:
%
%  load('CrackRestartfileExample.mat','CtrlVarInRestartFile','MUA','F','BCs','GF')
%   CtrlVar=CtrlVarInRestartFile;
%  speed=sqrt(F.ub.*F.ub+F.vb.*F.vb);
%  Par.MinPlottedSpeed=max(speed);
%  Par.VelColorBarTitle=' ';
%  Par.PlotXYscale=CtrlVar.PlotXYscale
%  figure
%  QuiverColorGHG(MUA.coordinates(:,1),MUA.coordinates(:,2),F.ub,F.vb,Par);
%  hold on ; PlotMuaBoundary(CtrlVar,MUA,'k')
%
% Plot velocities at approx equally spaced intervals:
%
%   load('CrackRestartfileExample.mat','CtrlVarInRestartFile','MUA','F','BCs','GF')
%   CtrlVar=CtrlVarInRestartFile;
%   x=MUA.coordinates(:,1);  y=MUA.coordinates(:,2);
%   [X,Y]=ndgrid(linspace(min(x),max(x),20),linspace(min(y),max(y),20));
%   I=nearestNeighbor(MUA.TR,[X(:) Y(:)]);  % finds nodes within computational grid closest to the regularly shaped X and Y grid points.
%   FigVelocities=figure;
%   Par.PlotXYscale=CtrlVar.PlotXYscale ;
%   Par.MinPlottedSpeed=0;
%   QuiverColorGHG(MUA.coordinates(I,1),MUA.coordinates(I,2),F.ub(I),F.vb(I),Par);
%   hold on ; PlotMuaBoundary(CtrlVar,MUA,'k')
%
%
% Plot velocities using logarithmic scaling.
%
%   load('CrackRestartfileExample.mat','CtrlVarInRestartFile','MUA','F','BCs','GF')
%   CtrlVar=CtrlVarInRestartFile;
%   FigVelocities=figure;
%   CtrlVar.VelPlotIntervalSpacing='log10' ;
%   QuiverColorGHG(MUA.coordinates(:,1),MUA.coordinates(:,2),F.ub,F.vb,CtrlVar);
%   hold on ; PlotMuaBoundary(CtrlVar,MUA,'k')
%
% Plotting velocities on top of FE mesh:
%
%   load('CrackRestartfileExample.mat','CtrlVarInRestartFile','MUA','F','BCs','GF')
%   CtrlVar=CtrlVarInRestartFile;
%   PlotMuaMesh(CtrlVar,MUA)
%   hold on
%   QuiverColorGHG(x,y,F.ub,F.vb,CtrlVar);
%
%
%
% Two calls with same velocity scaling:
%
%   [cbar,~,Par]=QuiverColorGHG(x,y,u,v,Par)  ; % first call, here Par is not strictly needed as an input
%   Par.QuiverSameVelocityScalingsAsBefore=1;
%   QuiverColorGHG(x,y,u,v,Par) ; % second call uses same scaling as previous one
%
%
% Note: When doing further contour plots on top of velocity plot, MATLAB will possibly change the
% limits of the colorbar and the position of the ticklables will no longer be correct.
% If this happens then reset range and ticks, for example:
%
%   [~,~,Par]=QuiverColorGHG(x,y,ub,vb);
% ...some other plots that affect the colorbar labels, colors, etc...
%   cbar=colorbar;
%   cbar.Ticks=Par.QuiverTicks*(cbar.Limits(2)-cbar.Limits(1))+cbar.Limits(1);
%   cbar.TickLabels=Par.QuiverTickLabels;
%   title(cbar,'(m/d)')   ;
%
%
% Note:  The variable Par is modified in the call and will, in general, be modified on return. If the same Par variable is
% then used again as an input to a subsequent call to QuiverColorGHG, those (modified) parameter values might affect the
% plot. The problem can be avoided by re-setting Par=[] in the second call, or by setting
% 
%    Par.QuiverSameVelocityScalingsAsBefore=false ; 
%    Par.MaxPlottedSpeed=[] ; 
%    Par.MinPlottedSpeed=[] ;
%    Par.QuiverColorSpeedLimits=[];
%
% ahead of a second call when using Par from a previous call.
%
%%

persistent SpeedPlotIntervals uvPlotScale QuiverTickLabels QuiverTicks QuiverCmap

if ~Par.QuiverSameVelocityScalingsAsBefore

    SpeedPlotIntervals=[];
    uvPlotScale=[];
    QuiverTickLabels=[];
    QuiverTicks=[];
    QuiverCmap=[];

    % if nargin>4
    % 
    %     Par.MaxPlottedSpeed=[] ;
    %     Par.MinPlottedSpeed=[] ;
    %     % Par.QuiverColorSpeedLimits=[] ; 
    %     % Par.VelPlotIntervalSpacing=[] ; 
    %     % Par.VelArrowColorSteps=[] ; 
    %     % Par.VelColorMap =[] ; 
    %     % Par.SpeedTickLabels=[] ; 
    % 
    % end



end

cbar=[];
QuiverHandel=[];

if isempty(x) || isempty(y) || isempty(u)   || isempty(v)
    return
end


if size(u,2)== 1 && (numel(x) ~= numel(y))
    error('Ua:QuiverColorGHG:xyDimensionsNotCompatible','x and y must have the same number of elements.')
end


if numel(u) ~= numel(v)
    error('Ua:QuiverColorGHG:uvDimensionsNotCompatible','u and v must have the same number of elements.')
end

%
% The expected typical usage is to plot one-dimensional arrays of velocities
% But u, v, x ,and y can also be given on a grid.
% If u and v is given on a grid, create vectors



if size(u,1)> 1 && size(u,2)>1 && ((size(x,2)==1 && size(y,2)==1)  || (size(x,1)==1 && size(y,1)==1 ))

    % u and v are matrices , x and y are vectors
    x=x(:) ; y=y(:) ;

    if size(u)==size(v)

        if (size(x,1)==size(u,1)) && (size(y,1)==size(u,2))

            [X,Y]=ndgrid(x,y) ;
            x=X(:) ; y=Y(:) ; u=u(:) ; v=v(:);
            clear X Y

        elseif (size(x,1)==size(u,2)) && (size(y,1)==size(u,1))

            warning('QuiverColorGHG:wrongdimensions','x and y are not grid vectors')

            [X,Y]=meshgrid(x,y) ;
            x=X(:) ; y=Y(:) ; u=u(:) ; v=v(:);
            clear X Y

        end
    end
end

x=x(:) ; y=y(:) ; u=u(:) ; v=v(:);

speed=sqrt(u.*u+v.*v); % speed is never scaled, so I can use speed to color velocity field based on values

if isinf(max(speed))

    fprintf(' Max of speed is infinite\n')

    I=isinf(speed);
    u(I)=NaN ; v(I)=NaN ; speed(I)=NaN;
    fprintf(' Seeting all such velocity values to NaN \n')

end


% now check Par fields, use all user-defined values where available, use default values otherwise
% and put in some reasonable for the remaining fields

if nargin>4 && ~isempty(Par)

    if ~isfield(Par,'QuiverColorPowRange')
        Par.QuiverColorPowRange=3;
    end

    if ~isfield(Par,'MaxPlottedSpeed')  || isempty(Par.MaxPlottedSpeed)

        if isfield(Par,'QuiverColorSpeedLimits')  && ~isempty(Par.QuiverColorSpeedLimits)
            Par.MaxPlottedSpeed=Par.QuiverColorSpeedLimits(2);
        else


            if all(speed==0)
                ticks=logticks(speed,Par.QuiverColorPowRange);
                Par.MaxPlottedSpeed=max(ticks);

            else
                %Par.MaxPlottedSpeed=max(speed(:))*1.001;
                Par.MaxPlottedSpeed=max(speed(:));
            end
        end
    end


    if ~isfield(Par,'MinPlottedSpeed')  || isempty(Par.MinPlottedSpeed)
        Par.MinPlottedSpeed=0;
    end

    if ~isfield(Par,'VelPlotIntervalSpacing') || isempty(Par.VelPlotIntervalSpacing)
        Par.VelPlotIntervalSpacing='lin';
    end


    if ~isfield(Par,'QuiverColorSpeedLimits')  || isempty(Par.QuiverColorSpeedLimits)

        switch Par.VelPlotIntervalSpacing
            case 'log10'

                ticks=logticks(speed,Par.QuiverColorPowRange,12);
                Par.QuiverColorSpeedLimits(1)=min(ticks);
                Par.QuiverColorSpeedLimits(2)=max(ticks);
            case 'lin'

                Par.QuiverColorSpeedLimits(1)=min(speed);
                Par.QuiverColorSpeedLimits(2)=max(speed);
        end
    end

    if ~isfield(Par,'uvPlotScale')
        Par.uvPlotScale=[];
    end


    if ~isfield(Par,'RelativeVelArrowSize') || isempty(Par.RelativeVelArrowSize)
        Par.RelativeVelArrowSize=1; % larger value makes vel arrows larger
    end

    if ~isfield(Par,'VelColorMap')
        Par.VelColorMap='jet';
    end

    if ~isfield(Par,'PlotXYscale')
        Par.PlotXYscale=1;
    end

    if ~isfield(Par,'VelArrowColorSteps')
        Par.VelArrowColorSteps=50;
    end

    if ~isfield(Par,'VelColorBarTitle')
        Par.VelColorBarTitle="($\mathrm{m \, yr^{-1}}$)" ;
    end



    if ~isfield(Par,'MinSpeedToPlot')
        Par.MinSpeedToPlot=0;
    end

    if ~isfield(Par,'SpeedTickLabels')
        Par.SpeedTickLabels=[];
    end

    if ~isfield(Par,'QuiverCmap')
        Par.QuiverCmap=[];
    end

    if ~isfield(Par,'QuiverSameVelocityScalingsAsBefore')
        Par.QuiverSameVelocityScalingsAsBefore=false ;
    end

    if Par.QuiverSameVelocityScalingsAsBefore

        if ~isempty(uvPlotScale)

            Par.uvPlotScale=uvPlotScale ;
            Par.SpeedPlotIntervals=SpeedPlotIntervals ;
            Par.QuiverTickLabels=QuiverTickLabels;
            Par.QuiverTicks=QuiverTicks ;
            Par.QuiverCmap=QuiverCmap;

        else
            Par.QuiverSameVelocityScalingsAsBefore=false ;
            fprintf('In QuiverColorGHG same scaling as in a previous call is requested, but the velocity scaling factor is not defined.\n')
            fprintf('Therefore, setting QuiverSameVelocityScalingsAsBefore=false \n')

        end
    end

else

    Par.RelativeVelArrowSize=1; % larger value makes vel arrows larger
    Par.VelArrowColorSteps=50;
    Par.uvPlotScale=[];
    Par.VelColorBarTitle="($\mathrm{m \, yr^{-1}}$)" ;
    Par.PlotXYscale=1;
    Par.VelColorMap='jet';
    Par.MaxPlottedSpeed=max(speed(:));
    Par.MinPlottedSpeed=min(speed(:));
    Par.VelPlotIntervalSpacing='lin';
    Par.QuiverColorSpeedLimits(1)=min(speed(:));
    Par.QuiverColorSpeedLimits(2)=max(speed(:));
    Par.MinSpeedToPlot=0;
    Par.SpeedTickLabels=[];
    Par.QuiverColorPowRange=3;
    Par.QuiverCmap=[];
    Par.QuiverSameVelocityScalingsAsBefore=0;

end

%%
% now all input variables should be OK
N=Par.VelArrowColorSteps;

if Par.QuiverSameVelocityScalingsAsBefore

    colormap(QuiverCmap)

    if isempty(Par.uvPlotScale) || ~isfield(Par,'uvPlotScale')
        fprintf('In QuiverColorGHG same scaling as in a previous call is requested, but the velocity scaling factor is not defined.\n')
        fprintf('Use parameters from previous call in this call!\n')
        error('Ua:QuiverColorGHG','The field uvPlotScale is not defiend')
    end
else


    if strcmp(Par.VelPlotIntervalSpacing,'log10')==1
        % create a `logarithmic' colormap

        if ~isnumeric(Par.VelColorMap)
            NN=10*N ;
            cmap=colormap(sprintf('%s(%i)',Par.VelColorMap,NN));
        else
            cmap=Par.VelColorMap ;
            NN=size(cmap,1);
        end
        index=fix((NN-1)*(exp((0:N-1)/(N-1))-1)/(exp(1)-1)+1);
        cmap=colormap(cmap(index,:));
    else

        if ~isnumeric(Par.VelColorMap)
            cmap=colormap(sprintf('%s(%i)',Par.VelColorMap,N));
        else
            cmap=Par.VelColorMap ;
            N=size(cmap,1);
        end
    end


    switch Par.VelPlotIntervalSpacing

        case 'log10'

            ticks=logticks(speed,Par.QuiverColorPowRange,12,Par.QuiverColorSpeedLimits);

            MinTick=min(ticks);

            if Par.QuiverColorSpeedLimits(1)<MinTick

                %Par.MinPlottedSpeed=MinTick;
                Par.QuiverColorSpeedLimits(1)=MinTick;
            end


            Par.SpeedPlotIntervals=logspace(log10(Par.QuiverColorSpeedLimits(1)),log10(Par.QuiverColorSpeedLimits(2)),N+1);

        case 'lin'

            %Par.SpeedPlotIntervals=linspace(Par.MinPlottedSpeed,Par.MaxPlottedSpeed,N+1);
            Par.SpeedPlotIntervals=linspace(Par.QuiverColorSpeedLimits(1),Par.QuiverColorSpeedLimits(2),N+1);

        otherwise
            fprintf(' which case {log10,lin}?' )
            error('QuiverColorGHG:VelPlotIntervalSpacing','case not reckognized')
    end




    Par.QuiverCmap=cmap;


    % scaling of velocity to get reasonably sized arrows


    Np=(sqrt(numel(x))/10);

    if Np<30 ; Np=30 ; end

    ps=min([max(x)-min(x) max(y)-min(y)])/Par.PlotXYscale*Par.RelativeVelArrowSize/Np;
    Par.uvPlotScale = Par.QuiverColorSpeedLimits(2)/ps  ;


end

uplot=u ; vplot=v;

% set velocities within plotting range
Ind=speed > Par.MaxPlottedSpeed;
uplot(Ind)=uplot(Ind)*Par.MaxPlottedSpeed./speed(Ind);
vplot(Ind)=vplot(Ind)*Par.MaxPlottedSpeed./speed(Ind);

Ind=speed < Par.MinPlottedSpeed;
uplot(Ind)=uplot(Ind)*Par.MinPlottedSpeed./speed(Ind);
vplot(Ind)=vplot(Ind)*Par.MinPlottedSpeed./speed(Ind);



%fprintf('QuiverColorGHG: uvPlotScale=%f \n',Par.uvPlotScale)

uplot=uplot/Par.uvPlotScale; vplot=vplot/Par.uvPlotScale;

%SpeedPlot=sqrt(uplot.*uplot+vplot.*vplot);
%sc=log(1+SpeedPlot)./x  ; I=isnan(sc) ; sc(I)=1;

% end

for J=1:numel(Par.SpeedPlotIntervals)-1

    switch J
        case 1
            I=speed <= Par.SpeedPlotIntervals(J+1) & speed>Par.MinSpeedToPlot;
        case N
            I=speed>Par.SpeedPlotIntervals(J) & speed>Par.MinSpeedToPlot;
        otherwise
            I=speed>Par.SpeedPlotIntervals(J) & speed <= Par.SpeedPlotIntervals(J+1) & speed>Par.MinSpeedToPlot;
    end

    if numel(x(I))>0  % This should not really be needed, but
        % results in errors in Matlab2016a
        QuiverHandel=quiver(x(I)/Par.PlotXYscale,y(I)/Par.PlotXYscale,uplot(I),vplot(I),0,...
            'color',Par.QuiverCmap(J,:),varargin{:}) ; hold on
    end
end


nPowRange=Par.QuiverColorPowRange;

if ~Par.QuiverSameVelocityScalingsAsBefore

    if verLessThan('matlab','8.4')

        %pre 2014b version
        cbar=colorbar; title(cbar,Par.VelColorBarTitle,"interpreter","latex")   ;

        if strcmp(Par.VelPlotIntervalSpacing,'log10')==1

            ms=fix(log10(Par.MaxPlottedSpeed));
            ticklabel=logspace(0,ms,ms+1);
            tickpos=1+N*log10(ticklabel)/log10(Par.SpeedPlotIntervals(N+1));
            set(cbar,'Ytick',tickpos,'YTicklabel',ticklabel);
        else
            clim([0 max(Par.SpeedPlotIntervals)]);
        end


    else

        if strcmp(Par.VelPlotIntervalSpacing,'log10')==1


            if ~isempty(Par.SpeedTickLabels)
                ticklabel=log10(Par.SpeedTickLabels);
            else
                % this is for more pleasing interval between labels (but needs to be improved)
                %D=(max(sp)-min(sp))/10 ; D=10.^round(log10(D)) ; ticklabel=unique(D*round(sp/D));
                ticklabel=logticks(speed,nPowRange,12,Par.SpeedPlotIntervals);
                %ticks=logticks(speed,12,Par.QuiverColorPowRange);
            end


            tickpos=(log10(ticklabel)-min(log10(Par.SpeedPlotIntervals)))/(max(log10(Par.SpeedPlotIntervals))-min(log10(Par.SpeedPlotIntervals)));


        else

            if ~isempty(Par.SpeedTickLabels)

                ticklabel=Par.SpeedTickLabels;
            else

                % this is for (hopefully) a more pleasing interval between labels
                D=(max(Par.SpeedPlotIntervals)-min(Par.SpeedPlotIntervals));
                if D==0  % special case if all values same or all values zero
                    D=mean(Par.SpeedPlotIntervals);
                    if D==0
                        ticklabel=[-1 0 1];
                        tickpos=(ticklabel+1)/2;
                    else
                        ticklabel=[D/2 D 1.5*D];
                        tickpos=(ticklabel-D/2)/D;
                    end
                else

                    D=double(10.^floor(log10(D)))/4 ;

                    first=D*floor(Par.SpeedPlotIntervals(1)/D);
                    last=D*ceil(Par.SpeedPlotIntervals(end)/D);

                    ticklabel=first:D:last;
                    tickpos=(ticklabel-min(Par.SpeedPlotIntervals))/(max(Par.SpeedPlotIntervals)-min(Par.SpeedPlotIntervals));
                    %tickpos=(ticklabel-first)/(last-first);

                    if numel(ticklabel)>10

                        ticklabel=ticklabel(1:2:end) ;
                        tickpos=tickpos(1:2:end) ;

                    end

                end
                %ticklabel=unique(D*round(sp/D));

            end


        end


        if any(isnan(tickpos))
            warning('QuiverColorGHG:NANinTickPos','calculated positions of ticks on the colorbar contain NaNs')
        end

        [tickpos,ia]=unique(tickpos);

        ticklabel=ticklabel(ia);
        colormap(Par.QuiverCmap)
        cbar=colorbar ;

        %cbar.TickLabels=ticklabel ;


        if ~any(isnan(tickpos))
            Ticks=tickpos*(cbar.Limits(2)-cbar.Limits(1))+cbar.Limits(1);
            %cbar.Ticks=Ticks; % tickpos*(cbar.Limits(2)-cbar.Limits(1))+cbar.Limits(1);
        end

        axis equal



        Par.QuiverTickLabels=ticklabel;
        Par.QuiverTicks=Ticks;

    end
end

if isempty(cbar)
    cbar=colorbar;
end
title(cbar,Par.VelColorBarTitle,"interpreter","latex")   ;
cbar.TickLabels=Par.QuiverTickLabels;
cbar.Ticks=Par.QuiverTicks;

% Par.QuiverColorSpeedLimits=[min(Par.SpeedPlotIntervals) max(Par.SpeedPlotIntervals)];
% Par.QuiverColorSpeedLimits=[];  % don't reuse these setting in next call


axis equal
% axis([min(x)/Par.PlotXYscale max(x)/Par.PlotXYscale min(y)/Par.PlotXYscale max(y)/Par.PlotXYscale])

uvPlotScale=Par.uvPlotScale ;
SpeedPlotIntervals=Par.SpeedPlotIntervals ;
QuiverTickLabels=Par.QuiverTickLabels;
QuiverTicks=Par.QuiverTicks ;
QuiverCmap=Par.QuiverCmap;


end


##### SOURCE END #####
-->
</body>
</html>
